class LinkedIn
types
public String = seq of char;
values
-- TODO Define values here
instance variables
private users : set of Person := {};
private avgDistance : nat := 0;
private usersMostContacts : set of Person := {};
inv card users >= 0;
operations

public LinkedIn: () ==> LinkedIn
LinkedIn() == (
return self;
);

-- Register use case
public registerUser: String * Person`Gender * nat1 ==> Person
registerUser(n, g, a) == (
dcl p:Person := new Person(n, g, a);
	addPerson(p);
	return p;
)
pre is_String(n) and is_Person`Gender(g) and is_nat1(a) and users <> undefined;--and (users = {} or card users >= 0); -- this last part is users <> nil

public addPerson: Person ==> ()
addPerson(p) == users := users union {p}
pre p not in set users
post users = users~ union {p};

-- Search Person use case
public searchPersonByName : String ==>  set of Person
searchPersonByName(name) == 
(
return  {p | p in set users & p.getName() = name};
)
pre is_String(name);  -- exists p in set users & p.getName() = name -----> is this part needed?


-- Add Connection use case
--public createConnection: String*String ==> ()
--createConnection(n,n1) == (dcl p:Person; dcl p1:Person;p := searchPersonByName(n); 
--p1 :=searchPersonByName(n1); p.addPerson(p1);p1.addPerson(p))
--pre exists p,p1 in set users & (p = searchPersonByName(n) and p1 = searchPersonByName(n1) and p<>p1 and n<>n1);


--public commonContacts : String*String ==> set of Person
--commonContacts(n,n1) == (dcl commonContacts: set of Person := {};dcl p:Person;dcl p1:Person;
--p := searchPersonByName(n);p1:= searchPersonByName(n1);
--for all c in set p.getConnections() do
-- if (c in set p1.getConnections())
-- then
-- 	commonContacts := commonContacts union {c};
--return commonContacts;)

--pre n <> n1 and  exists p,p1 in set users & (  p.getName() = n and p1.getName() = n1 and p<>p1)
--post exists p,p1 in set users & ( p.getName() = n and p1.getName() = n1 and 
--(
--forall c in set RESULT, c1 in set  p.getConnections() ,c2 in set  p1.getConnections() &
-- c in set p.getConnections() and c in set p1.getConnections() and (c1<>c2 or c1 = c2 and c1 in set RESULT )));


 
mostContacts:() ==> Person
mostContacts() == return iota p in set users & (not exists p1 in set users & p.connectionsSize() > p1.connectionsSize())
pre users <> {}; 

 --addCV: String*String ==> ()
 --addCV(n,cv) == (
 --dcl p:Person:= searchPersonByName(n);
-- p.addCV(cv);
 --)
 --pre exists p in set  users & (p = searchPersonByName(n) );

averageDistance : () ==> nat
averageDistance() == ( 
dcl visited : set of Person := {}; 
dcl distance: nat := 0;dcl resto : set of Person := {};
  resto := users\visited;  
 while resto <> {} do
let x in set resto in(
 visited:= visited union {x};
  resto := users\visited;
 distance:= distance+distanceAux(x,resto));
 return distance )
pre users <> {};

--Melhorar pre e pos condições principalmente nestas + complicadas, no idea how, but we should do it somehow 

-- In response to that: acho que temos de definir bem se queremos que a pos condicao restrinja so o output, ou se
-- vai restringir tambem o final system state apos a funcao ser corrida
distanceAux : Person*set of Person ==> nat
distanceAux(p,s) == (
dcl distanceAux: nat :=0;
dcl sAux :set of Person :=s;
while sAux <> {} do
let x in set sAux in(
 sAux:= sAux\{x};
distanceAux:= distanceAux + distanceBetweenPeople(p,x);
 );
 return distanceAux/ (card s))
 pre s <> {}
 post RESULT >=0;

distanceBetweenPeople:Person*Person ==> nat 
distanceBetweenPeople(p,p1) == return 1
pre users <> {};

pure searchPersonByNameOld : String ==> Person
searchPersonByNameOld(nome) == return iota p in set users & p.getName() = nome 
pre exists1 p in set users & p.getName() = nome;

functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end LinkedIn