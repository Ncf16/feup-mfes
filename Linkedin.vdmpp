class Linkedin
types
public String = seq of char;
values
-- TODO Define values here
instance variables
private users : set of Person := {};
private avgDistance : nat := 0;
private usersMostContacts : set of Person := {};
operations

public addPerson: Person ==> ()
addPerson(p) == users := users union {p}
pre p not in set users
post users = users~ union {p};


public createConnection: String*String ==> ()
createConnection(n,n1) == (dcl p:Person; dcl p1:Person;p := searchPersonByName(n); 
p1 :=searchPersonByName(n1); p.addPerson(p1);p1.addPerson(p))
pre exists p,p1 in set users & (p = searchPersonByName(n) and p1 = searchPersonByName(n1) and p<>p1 and n<>n1);


public commonContacts : String*String ==> set of Person
commonContacts(n,n1) == (dcl commonContacts: set of Person := {};dcl p:Person;dcl p1:Person;
p := searchPersonByName(n);p1:= searchPersonByName(n1);
for all c in set p.getConnections() do
 if (c in set p1.getConnections())
 then
 	commonContacts := commonContacts union {c};
return commonContacts;)

pre n <> n1 and  exists p,p1 in set users & (  p.getName() = n and p1.getName() = n1 and p<>p1)
post exists p,p1 in set users & ( p.getName() = n and p1.getName() = n1 and 
(
forall c in set RESULT, c1 in set  p.getConnections() ,c2 in set  p1.getConnections() &
 c in set p.getConnections() and c in set p1.getConnections() and (c1<>c2 or c1 = c2 and c1 in set RESULT )));


 
mostContacts:() ==> Person
mostContacts() == return iota p in set users & (not exists p1 in set users & p.connectionsSize() > p1.connectionsSize())
pre users <> {}; 

 addCV: String*String ==> ()
 addCV(n,cv) == (
 dcl p:Person:= searchPersonByName(n);
 p.addCV(cv);
 )
 pre exists p in set  users & (p = searchPersonByName(n) );

averageDistance : () ==> nat
averageDistance() == ( 
dcl visited : set of Person := {}; 
dcl distance: nat := 0;dcl resto : set of Person := {};
  resto := users\visited;  
 while resto <> {} do
let x in set resto in(
 visited:= visited union {x};
  resto := users\visited;
 distance:= distance+distanceAux(x,resto));
 return distance )
pre users <> {};

--Melhorar pre e pos condições principalmente nestas + complicadas, no idea how, but we should do it somehow 

-- In response to that: acho que temos de definir bem se queremos que a pos condicao restrinja so o output, ou se
-- vai restringir tambem o final system state apos a funcao ser corrida
distanceAux : Person*set of Person ==> nat
distanceAux(p,s) == (
dcl distanceAux: nat :=0;
dcl sAux :set of Person :=s;
while sAux <> {} do
let x in set sAux in(
 sAux:= sAux\{x};
distanceAux:= distanceAux + distanceBetweenPeople(p,x);
 );
 return distanceAux/ (card s))
 pre s <> {}
 post RESULT >=0;

distanceBetweenPeople:Person*Person ==> nat 
distanceBetweenPeople(p,p1) == return 1
pre users <> {};

pure searchPersonByName : String ==> Person
searchPersonByName(nome) == return iota p in set users & p.getName() = nome 
pre exists1 p in set users & p.getName() = nome;

functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Linkedin